#!/usr/bin/env python
"""
Script to generate a consolidated requirements.txt file from all uv.lock files in the project.
"""

import os
import sys
import tomli
import re
from collections import defaultdict
from pathlib import Path

# Project root directory
ROOT_DIR = Path(__file__).parent.parent.absolute()


def find_uv_lock_files():
    """Find all uv.lock files in the project."""
    uv_lock_files = []
    
    # Add root uv.lock if it exists
    root_uv_lock = ROOT_DIR / "uv.lock"
    if root_uv_lock.exists():
        uv_lock_files.append(root_uv_lock)
    
    # Recursively find all uv.lock files in subdirectories
    for root, dirs, files in os.walk(ROOT_DIR):
        # Skip the .venv directories
        if '.venv' in dirs:
            dirs.remove('.venv')
        
        # Skip the root directory (already handled)
        if Path(root) == ROOT_DIR:
            continue
            
        # Check for uv.lock files
        if 'uv.lock' in files and 'pyproject.toml' in files:
            uv_lock_path = Path(root) / 'uv.lock'
            uv_lock_files.append(uv_lock_path)
            print(f"Found uv.lock in {root}")
    
    return uv_lock_files


def parse_uv_lock(file_path):
    """Parse a uv.lock file and extract package information."""
    try:
        with open(file_path, "rb") as f:
            lock_data = tomli.loads(f.read().decode("utf-8"))
        
        packages = {}
        for package in lock_data.get("package", []):
            name = package.get("name")
            version = package.get("version")
            if name and version:
                packages[name] = version
        
        return packages
    except Exception as e:
        print(f"Error parsing {file_path}: {e}")
        return {}


def generate_requirements():
    """Generate a consolidated requirements.txt file."""
    # Find all uv.lock files
    uv_lock_files = find_uv_lock_files()
    
    if not uv_lock_files:
        print("No uv.lock files found in the project.")
        return
    
    # Parse each uv.lock file
    all_packages = defaultdict(list)
    for file_path in uv_lock_files:
        print(f"Processing {file_path}")
        packages = parse_uv_lock(file_path)
        for name, version in packages.items():
            all_packages[name].append(version)
    
    # Generate requirements.txt
    with open(ROOT_DIR / "requirements.txt", "w") as f:
        f.write("# Consolidated requirements from all uv.lock files\n")
        f.write("# Generated by scripts/generate_requirements.py\n\n")
        
        for name, versions in sorted(all_packages.items()):
            # Use the highest version if there are conflicts
            if len(set(versions)) > 1:
                # Sort versions to pick the highest
                sorted_versions = sorted(versions, key=lambda v: [int(x) for x in re.findall(r'\d+', v) if x.isdigit()], reverse=True)
                f.write(f"# Warning: Multiple versions found for {name}: {', '.join(versions)}\n")
                f.write(f"{name}=={sorted_versions[0]}\n")
            else:
                f.write(f"{name}=={versions[0]}\n")
    
    print(f"Generated requirements.txt with {len(all_packages)} packages.")


if __name__ == "__main__":
    # Ensure we're running from the project root
    os.chdir(ROOT_DIR)
    
    print(f"Generating consolidated requirements.txt for {ROOT_DIR}")
    generate_requirements()
    print("Done!") 